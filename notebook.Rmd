---
title: "Desafio Intro ML - Curso-R"
author: "Ricardo Mattos"
date: "12/07/2020"
output:
  html_notebook:
    toc: yes
    toc_float: yes
    number_sections: yes
  html_document:
    toc: yes
    toc_float: yes
    number_sections: yes
---


```{r setup, include=FALSE}
library(readr)
library(tidymodels)
library(ggplot2)
library(skimr)
library(RCurl)
library(kableExtra)
library(gridExtra)
library(glue)
library(forcats)
library(DataExplorer)
```

# Objetivo

O objetivo desse notebook é efetuar todo o processo de modelagem da base de dados `adult`, disponibilizada para o desafio do curso de introdução ao Machine Learning da Curso-R, utilizando o framework `tidymodels`. Ou seja, explorar, tratar, preparar, tunnar e escolher o modelo que melhor se ajusta aos dados disponibilizados. Vamos nessa!


# Leitura da base

## Informações preliminares

```{r}
adult <- read_rds("adult.rds")

# head(adult) 

# glimpse(adult)
skim(adult)

```



<br> As variáveis parecem estar com formatos corretos. Ponto de atenção para as variáveis `wokclass`, `occupation` e `native_country`, que apresentam valores missing.  </br>


# AED 

<br> Agora vamos analisar o comportamento das variáveis para definirmos como tratar os nossos dados para o modelo. </br>

## Análise bivariada {.tabset}

```{r,results='asis', echo=TRUE, message=FALSE, warning=FALSE}


# DataExplorer::create_report(adult)

devtools::source_url("https://raw.githubusercontent.com/ricardomattos05/functions/master/function_AED_bivariada.R")
# 
# 
adult2 <- adult %>%
            select(-id) %>% 
            mutate(resposta = if_else(resposta == ">50K", 1, 0))
# 
# 

# names(adult2)
for (i in 1:(length(adult2)-1) ) {
  
  df <- adult2[,c(i,15)]
  cat("### ",names(df[,1]),"\n") 
  print(AED_biv(df,glue("resposta"),"Pre"))
  cat('\n\n')
}



```


## {-}

Observações:

* `education` : é possível visualizar que quanto maior o grau de escolaridade, maior a proporção de pessoas com salarios acima de 50k. E que as categorias abaixo de HS-grad, `1th-4th` até `12th`além de serem pouco representativas, possuem baixa proporção, vamos então criar uma categoria uma nova consolidando elas `HS-not-grad`.

* `marital_status` : aqui iremos agrupar os campos `Married-AF-spouse` e `Married-civ-spouse`, criando a categoria `Married`, baseado na similaridade entre elas com relação a variável resposta e considerando a descrição delas.

* `native_country` : É um campo com pouca variabilidade, onde `r (adult %>% select(native_country) %>% filter(native_country == "United-States") %>% count() / count(adult)) %>% as.numeric() %>% percent()` dos dados estão atribuídos como "Estados Unidos". Sendo assim, poderia considerar apenas Estados Unidos e agrupar o restante como outros, mas vamos manter o máximo de informação e reduzir as categorias para 3, agrupando todos os países que obtiveram proporção maior que a média, manter o valor mais representativo e uma categoria com os países abaixo da média.

* `relationship` : campo contém os campos `husband` e `wife`, aparentemente poderiamos agrupa-los, vamos analisar mais afundo.

* `capital_loss` e `capital_gain` : Aparentemente tanto quem ganha quanto quem perde algum valor apresentam maiores probabilidades de ter salario >50k. Vamos então avaliar a correlação entre elas.

* `workclass` : Categorias com baixa representatividade como `Never-worked`e `Without-pay` não possuem classificação com a resposta de interesse ">50k", vamos dar um zoom nessa variável e analisar os NA's que identificamos também.

## AED final: {.tabset}

### occupation

```{r}

ggplot(adult, aes(x = occupation, fill = resposta)) + 
  geom_bar(position="fill") + 
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("occupation")

```

<br> É possível ver que não faria sentido atribuir os NAs de forma modal, uma vez que nosso objetivo é obter o maior poder preditivo possível, logo, não queremos perder informação. Sendo assim, não vamos diluir os NAs na categoria com maior representatividade `Prof-specialty`, vamos atribuir à uma categoria com proporções similares e que possui uma boa representatividade, `Farming-fishing`. </br>


### relationship
```{r}

ggplot(adult, aes(x = relationship)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("relationship")

ggplot(adult, aes(x = relationship, fill = resposta)) + 
  geom_bar(position="fill") + 
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("relationship")

ggplot(adult, aes(x = relationship, fill = sex)) + 
  geom_bar(position="fill") + 
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("relationship")

```

Vamos então balancear o gênero agrupando as categorias Wife e Husband, criando a categoria `Married`.

### Capital Gain and Loss


```{r, echo = TRUE}

ggplot(adult, aes(x= capital_gain, y= capital_loss)) +
  geom_point()
```



```{r}
sum(adult$capital_loss > 0 & adult$capital_gain > 0)
```
Sendo assim, podemos soma-las e criar a variável `capital_total` sem medo de perder informação.

### Worclass

```{r}

ggplot(adult, aes(x = workclass)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("Workclass")

ggplot(adult, aes(x = workclass, fill = resposta)) + 
  geom_bar(position="fill") + 
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("Workclass")

```

Pelo visto a catgoria NA possui relação com a variável resposta distinta de todas as outras categorias, vamos então gerar uma nova categoria `not-identify` para atribuir os valores NA.


### native_country

```{r}

med <- (adult %>% 
          select(resposta) %>%
          filter(resposta == ">50K") %>% 
          count() %>% 
          as.numeric())/nrow(adult)
         

tb_country<- adult %>% 
                select(native_country, resposta) %>% 
                group_by(native_country) %>% 
                count(resposta) %>% 
                mutate(prop = prop.table(n)) %>% 
                filter(resposta == ">50K") %>% 
                mutate( class = case_when( native_country == "United-States" ~ "United-States",
                                           prop > med ~ ">mean",
                                           prop <= med ~ "<=mean" )  )

tb_country %>% 
  select(native_country,class) %>% 
  group_by(class) %>% 
  count()



```


Ficamos então com 21 países com proporções abaixo da méda, 18 acima e "United-States" como as 3 categorias restantes.


```{r, echo=FALSE}

# tb_country %>%
#         filter(class == "<=mean") %>%
#         select(native_country) %>%
#         as.factor()


adult2<- adult2 %>%
    mutate(class_country = case_when(native_country %in% c("Cambodia", "Canada", "China", "Cuba", "England", "France", "Germany", "Greece", "Hong", "India", "Iran", "Italy", "Japan", "Philippines", "Scotland", "Taiwan", "Yugoslavia", NA)  ~ ">mean",
                             native_country == "United-States" ~ "United-States",
                             TRUE ~ "<=mean") )     

# adult2 %>% 
#   filter(class == ">mean") %>% 
#   select(native_country) %>% 
#   group_by(native_country) %>% 
#   count()

ggplot(adult2, aes(x = class_country)) +
  geom_bar(aes(y = (..count..)/sum(..count..))) +
  geom_text(stat = "count", 
            aes(label = round((..count..)/sum(..count..), 2), y = ..prop.. + 0.02))+
  theme(axis.text.x = element_text(angle = 90)) + 
  scale_y_continuous(labels=percent)+ ylab("prop")+
  ggtitle("class_country")

ggplot(adult2, aes(x = class_country, fill = as.factor(resposta) )) + 
  geom_bar(position="fill") + 
  theme(axis.text.x = element_text(angle = 90)) + 
  scale_y_continuous(labels=percent)+
  ggtitle("class_country")
    
    
```

<br>A distribuição ficou com 5% para países acima da média e 5% para países abaixo da média.</br>

# Modelagem

Com nossa a análise exploratória concluída, vamos dar início as estapas da modelagem utilizando o framework do `tidymodels`.

## Amostragem

Fazendo a separação dos dados em treino e teste para a modelagem.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
set.seed(32)

adult_split <- initial_split(adult, prop = 0.8, strata = resposta)

adult_train <- training(adult_split)
adult_test <- testing(adult_split)

```


## Data Prep

Os tratamentos necessários observados na AED, que foi feita utilizando o pacote `DataExplorer` e a função [`AED_biv`](https://github.com/ricardomattos05/functions/blob/master/function_AED_bivariada.R) que gerei para entender o comportamento das variáveis com relação a variável resposta, serão armazenados utilizando o recipes para ser utilizado tanto para treinar os modelos como para testar posteriormente.


```{r}

adult_recipe <- 
  recipe(resposta ~ ., data = adult_train) %>% 
  step_mutate(
    
    occupation = case_when(
      is.na(occupation) ~ "Farming-fishing",
      TRUE ~ as.character(occupation)),
    
    workclass = case_when(
      is.na(workclass) ~ "Not-identify",
      TRUE ~ as.character(workclass)),
    
    class_country = case_when(native_country %in% c("Cambodia", "Canada", "China", "Cuba", "England", "France", "Germany", "Greece", "Hong", "India", "Iran", "Italy", "Japan", "Philippines", "Scotland", "Taiwan", "Yugoslavia", NA) ~ "greater_mean",
                             native_country == "United-States" ~ "United-States",
                             TRUE ~ "smaller_mean")
    ,
    
    capital_total = capital_gain + capital_loss
    , 
    
    marital_status = case_when(
      marital_status %in% c("Married-AF-spouse" , "Married-civ-spouse") ~ "Married",
      TRUE ~ as.character(marital_status))
    ,
    
    education = case_when(education %in% c("1st-4th", "5th-6th", "7th-8th", "9th", "10th", "11th", "12th") ~ "HS-not-grad",
                          TRUE ~ as.character(education))
    ,
    
    relationship = case_when(  relationship %in% c("Husband","Wife") ~ "Married",
                               TRUE ~ as.character(relationship))
    
  ) %>% 
  step_rm(id, capital_gain, capital_loss, native_country)%>% 
  step_string2factor(all_nominal()) %>%
  step_normalize(all_numeric()) %>% 
  step_zv(all_predictors()) %>%
  step_novel(all_nominal(), -all_outcomes()) %>% 
  step_dummy(all_nominal(), -all_outcomes())

 # bake(prep(adult_recipe), adult_train)


adult_wf <- 
  workflow() %>% 
  add_recipe(adult_recipe)
```



## Cross-Validation

Especificando a validação cruzada:

```{r}
set.seed(32)
adult_vfold <- vfold_cv(adult_train, v = 5, strata = resposta)
adult_vfold
```

## Modelos {.tabset}

Os modelos que serão ajustados:

  * Decision tree
  * Random Forest
  * Xgboost
  
### Decision tree

Especificando modelo:

```{r}
adult_tree <- 
  decision_tree(
    min_n = tune(),
    cost_complexity = tune(), 
    tree_depth = tune()) %>%
  set_mode("classification") %>%
  set_engine("rpart")

adult_tree
```
Workflow para decision tree:

```{r}

workflow_adult_tree <- 
  adult_wf %>% 
  add_model(adult_tree)


```

Parâmentros:

```{r}
hiperparams <- parameters(
 adult_tree
)
hiperparams
```

Grid:

```{r}
set.seed(32)
tree_grid <- grid_max_entropy(hiperparams, size = 10)

```


Efetuando tunagem de hiperparâmetros:

```{r, echo= TRUE}

tree_tune <- 
  workflow_adult_tree %>% 
  tune_grid(
    resamples = adult_vfold,
    grid = tree_grid,
    control = control_grid(save_pred = TRUE, verbose = T, allow_par = F),
    metrics = metric_set(roc_auc)
  )

```

```{r}
autoplot(tree_tune)
show_best(tree_tune, "roc_auc")

tree_best_hiperparams <- select_best(tree_tune) #1.175764e-05	8	13	Model07 (roc_auc = 0.9008466)
tree_best_hiperparams

```

Finalizando WF:

```{r}
workflow_tree_final <- finalize_workflow(
  workflow_adult_tree,
  tree_best_hiperparams
)

workflow_tree_final
```


Verificando importância dos atributos:

```{r}
workflow_tree_final %>%
  fit(adult_train) %>%
  pull_workflow_fit() %>%
  vip::vip(geom = "col")
```


Modelo final:

```{r}

tree_final <- last_fit(workflow_tree_final, adult_split)
collect_metrics(tree_final) # roc_auc = 0.8947624

```



### Random Forest

Especificando modelo:

```{r}
adult_rf <- 
  rand_forest(
    min_n = tune(),
    mtry = tune(),
    trees = tune()) %>%
  set_mode("classification") %>%
  set_engine("randomForest")

adult_rf
```