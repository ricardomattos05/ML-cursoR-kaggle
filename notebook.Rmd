---
title: "Desafio Intro ML - Curso-R"
author: "Ricardo Mattos"
date: "12/07/2020"
output:
  html_notebook:
    toc: yes
    toc_float: yes
    number_sections: yes
  html_document:
    toc: yes
    toc_float: yes
    number_sections: yes
---


```{r setup, include=FALSE}
library(readr)
library(tidymodels)
library(ggplot2)
library(skimr)
library(RCurl)
library(kableExtra)
library(gridExtra)
library(glue)
library(forcats)
library(DataExplorer)
```

# Objetivo

O objetivo desse notebook é efetuar todo o processo de modelagem da base de dados `adult`, disponibilizada para o desafio do curso de introdução ao Machine Learning da Curso-R, utilizando o framework `tidymodels`. Ou seja, explorar, tratar, preparar, tunnar e escolher o modelo que melhor se ajusta aos dados disponibilizados. Vamos nessa!


# Leitura da base

## Informações preliminares

```{r}
adult <- read_rds("adult.rds")

# head(adult) 

# glimpse(adult)
skim(adult)

```



<br> As variáveis parecem estar com formatos corretos. Ponto de atenção para as variáveis `wokclass`, `occupation` e `native_country`, que apresentam valores missing.  </br>


## Amostragem

Já vamos fazer a separação dos dados em treino e teste para a modelagem.

```{r, echo=TRUE, message=FALSE, warning=FALSE}
set.seed(32)

adult_split <- initial_split(adult, prop = 0.8, strata = resposta)

adult_train <- training(adult_split)
adult_test <- testing(adult_split)

```


# AED 

<br> Agora vamos analisar o comportamento das variáveis para definirmos como tratar os nossos dados para o modelo. </br>

## Análise bivariada {.tabset}

```{r,results='asis', echo=TRUE, message=FALSE, warning=FALSE}


# DataExplorer::create_report(adult)

devtools::source_url("https://raw.githubusercontent.com/ricardomattos05/functions/master/function_AED_bivariada.R")
# 
# 
adult2 <- adult %>%
            select(-id) %>% 
            mutate(resposta = if_else(resposta == ">50K", 1, 0))
# 
# 

# names(adult2)
for (i in 1:(length(adult2)-1) ) {
  
  df <- adult2[,c(i,15)]
  cat("### ",names(df[,1]),"\n") 
  print(AED_biv(df,glue("resposta"),"Pre"))
  cat('\n\n')
}



```


## {-}

Observações:

* `education` : é possível visualizar que quanto maior o grau de escolaridade, maior a proporção de pessoas com salarios acima de 50k. E que as categorias abaixo de HS-grad, `1th-4th` até `12th`além de serem pouco representativas, possuem baixa proporção, vamos então criar uma categoria uma nova consolidando elas `HS-not-grad`.

* `marital_status` : aqui iremos agrupar os campos `Married-AF-spouse` e `Married-civ-spouse`, criando a categoria `Married`, baseado na similaridade entre elas com relação a variável resposta e considerando a descrição delas.

* `native_country` : É um campo com pouca variabilidade, onde `r (adult %>% select(native_country) %>% filter(native_country == "United-States") %>% count() / count(adult)) %>% as.numeric() %>% percent()` dos dados estão atribuídos como "Estados Unidos". Sendo assim, poderia considerar apenas Estados Unidos e agrupar o restante como outros, mas vamos manter o máximo de informação e reduzir as categorias para 3, agrupando todos os países que obtiveram proporção maior que a média, manter o valor mais representativo e uma categoria com os países abaixo da média.

* `relationship` : campo contém os campos `husband` e `wife`, aparentemente poderiamos agrupa-los, vamos analisar mais afundo.

* `capital_loss` e `capital_gain` : Aparentemente tanto quem ganha quanto quem perde algum valor apresentam maiores probabilidades de ter salario >50k. Vamos então avaliar a correlação entre elas.

* `workclass` : Categorias com baixa representatividade como `Never-worked`e `Without-pay` não possuem classificação com a resposta de interesse ">50k", vamos dar um zoom nessa variável e analisar os NA's que identificamos também.

## AED final: {.tabset}

### occupation

```{r}

ggplot(adult, aes(x = occupation, fill = resposta)) + 
  geom_bar(position="fill") + 
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("occupation")

```

<br> É possível ver que não faria sentido atribuir os NAs de forma modal, uma vez que nosso objetivo é obter o maior poder preditivo possível, logo, não queremos perder informação. Sendo assim, não vamos diluir os NAs na categoria com maior representatividade `Prof-scpeciality`, vamos atribuir à uma categoria com proporções similares e que possui uma boa representatividade, `Farming-fishing`. </br>


### relationship
```{r}

ggplot(adult, aes(x = relationship)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("relationship")

ggplot(adult, aes(x = relationship, fill = resposta)) + 
  geom_bar(position="fill") + 
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("relationship")

ggplot(adult, aes(x = relationship, fill = sex)) + 
  geom_bar(position="fill") + 
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("relationship")

```

Vamos então balancear o gênero agrupando as categorias Wife e Husband, criando a categoria `Married`.

### Capital Gain and Loss


```{r, echo = TRUE}

ggplot(adult, aes(x= capital_gain, y= capital_loss)) +
  geom_point()
```



```{r}
sum(adult$capital_loss > 0 & adult$capital_gain > 0)
```
Sendo assim, podemos soma-las e criar a variável `capital_total` sem medo de perder informação.

### Worclass

```{r}

ggplot(adult, aes(x = workclass)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("Workclass")

ggplot(adult, aes(x = workclass, fill = resposta)) + 
  geom_bar(position="fill") + 
  theme(axis.text.x = element_text(angle = 90)) + 
  ggtitle("Workclass")

```

Pelo visto a catgoria NA possui relação com a variável resposta distinta de todas as outras categorias, vamos então gerar uma nova categoria `not-identify` para atribuir os valores NA.


### native_country

```{r}

med <- (adult %>% 
          select(resposta) %>%
          filter(resposta == ">50K") %>% 
          count() %>% 
          as.numeric())/nrow(adult)
         

tb_country<- adult %>% 
                select(native_country, resposta) %>% 
                group_by(native_country) %>% 
                count(resposta) %>% 
                mutate(prop = prop.table(n)) %>% 
                filter(resposta == ">50K") %>% 
                mutate( class = case_when( native_country == "United-States" ~ "United-States",
                                           prop > med ~ ">mean",
                                           prop <= med ~ "<=mean" )  )

tb_country %>% 
  select(native_country,class) %>% 
  group_by(class) %>% 
  count()



```


Ficamos então com 21 países com proporções abaixo da méda, 18 acima e "United-States" como as 3 categorias restantes.


```{r, echo=FALSE}

# tb_country %>%
#         filter(class == "<=mean") %>%
#         select(native_country) %>%
#         as.factor()


adult2<- adult2 %>%
    mutate(class_country = case_when(native_country %in% c("Cambodia", "Canada", "China", "Cuba", "England", "France", "Germany", "Greece", "Hong", "India", "Iran", "Italy", "Japan", "Philippines", "Scotland", "Taiwan", "Yugoslavia", NA)  ~ ">mean",
                             native_country == "United-States" ~ "United-States",
                             TRUE ~ "<=mean") )     

# adult2 %>% 
#   filter(class == ">mean") %>% 
#   select(native_country) %>% 
#   group_by(native_country) %>% 
#   count()

ggplot(adult2, aes(x = class_country)) +
  geom_bar(aes(y = (..count..)/sum(..count..))) +
  geom_text(stat = "count", 
            aes(label = round((..count..)/sum(..count..), 2), y = ..prop.. + 0.02))+
  theme(axis.text.x = element_text(angle = 90)) + 
  scale_y_continuous(labels=percent)+ ylab("prop")+
  ggtitle("class_country")

ggplot(adult2, aes(x = class_country, fill = as.factor(resposta) )) + 
  geom_bar(position="fill") + 
  theme(axis.text.x = element_text(angle = 90)) + 
  scale_y_continuous(labels=percent)+
  ggtitle("class_country")
    
    
```

<br>A distribuição ficou com 5% para países acima da média e 5% para países abaixo da média.</br>

